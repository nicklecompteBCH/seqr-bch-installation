"""The graphs module contains a few simple, performance-naive
datatypes and functions around the processing of simple
graph structures. They are intended for cloud-sized graphs if you
are not Netflix (e.g a medium cluster with a few smaller ones).

"""
from typing import (
    TypeVar, List, Dict,
    Generic, Union, Set,
    Tuple, Callable
)
from common.exceptions import InvalidTypeException
from common.helpers import (
    group_by,
    deep_copy
)

T = TypeVar("T")
U = TypeVar("U")

# Test coverage:
# - star construction works
# - star iteration works
# - star can be made a valid Graph

class Star(Generic[T,U]):
    """A simple graph with a designated central vertex and a list of leaves.

    Example:
        Star(1, [2,3,4,5,6]) is a Star[Int,Int] with the following graph:

        2           3
        |_____ _____|
            _ 1 _
        |--|  |  |---|
        4     5      6

    :param center: The designated center of the graph. The only vertex with > 1 adjacent node.
    :type center: T. T MUST have an implementation of __hash__.
    :param leaves: A list of nodes adjacent ONLY to the center.
    :type leaves: Set[U]. By construction U MUST have an implementation of __hash__.
    :param is_directed: Is the star directed (True, center points out to leaves) or undirected (both ways), defaults to True
    :type is_directed: bool, optional
    """

    def __init__(
        self,
        center : T,
        leaves: Set[U],
        is_directed = True
    ):
        vertex_list = [center] + list(leaves)
        if len(set(vertex_list)) != len(vertex_list):
            if center in leaves:
                raise ValueError(f"Center and leaves of a star must be distinct, {center} was in both.")
            grouped = group_by(vertex_list, lambda x : x)
            for g in grouped:
                if len(grouped[g]) > 1:
                    raise ValueError(f"Each leaf of a star must be unique. Saw the following repeats: {grouped[g]}")
        self._vertex_set = set(vertex_list)
        self.center = center
        self.leaves = leaves
        self._adjacency_map = None
        self.is_directed = is_directed

    def get_vertex_set(self) -> List[T]:
        """Get the vertex set (i.e. the center + the leaves).
        Simple helper function.

        :return: [self.center] + self.leaves
        :rtype: List[T]
        """
        if self._vertex_set is not None:
            # It really shouldn't be! But just in case (refactor robustness etc)
            return self._vertex_set
        retset = set([self.center] + self.leaves)
        return retset


    def get_adjacency_map(self) -> Dict[T, List[U]]:
        """Converts a Star into an adjacency map dictionary.
        For details, please see the docstring at the top of this module,
        as well as the documentation on the Graph class
        and associated private functions.

        :return: A dictionary describing adjacency as in the docstring at the top of this module.
        :rtype: Dict[T, List[U]]
        """
        if self._adjacency_map is not None:
            # This could very well be None, it is lazily memoized.
            return self._adjacency_map
        # If self._adjacency_map is None, compute the adjacency map.
        retdict = {self.center: self.leaves}
        for leaf in self.leaves:
            if self.is_directed:
                retdict.update({leaf: set()})
            else:
                retdict.update({leaf: set([self.center])})
        # set the cache for memoized computation
        self._adjacency_map = retdict
        return retdict

    def __contains__(
        self,
        item: T
    ):
        if self._vertex_set:
            return item in self._vertex_set
        else:
            if item == self.center:
                return True
            else:
                return item in self.leaves

    def __eq__(self, other):
        return self.center == other.center and self.leaves == other.leaves

    def __len__(self):
        return len(self.leaves) + 1

    def __hash__(self):
        init_hash = hash(self.center)
        for leaf in self.leaves:
            init_hash = init_hash + (hash(leaf))
        return init_hash

    def __iter__(self):
        yield self.center
        yield from self.leaves



TNode = TypeVar("TNode")
TTree = TypeVar("TTree")

class Path(Generic[TNode]):
    """A path is a very particular type of Graph, with more information than its simple topology.

    Paths are designed to be generated by other graphs, which may or may not be connected.

    Hence there is a complete path by default, but also an idea of an incomplete path,
    which is what is created when a disconnected graph (or specifically a directed graph without much bidirection)
    tries to get a path between disjoint vertices.

    :param TNode: The types of nodes (aka vertices, or aka VMs in a cluster) in the path.
    :raises ValueError: [description]
    :param input_list: The list of TNodes in the path, asserted by construction to be consecutive.
    :type input_list: List[TNode]
    :param complete_path: Is the path complete? Did it reach its attempted endpoint? Defaults to True.
    :type complete_path: bool, optional
    :param attempted_endpoint: The endpoint the path attempted to reach. Defaults to None.
    :type attempted_endpoint: Union[TNode,None], optional
    :raises ValueError: [description]
    :return: [description]
    :rtype: Path[TNode]
    """

    def __init__(
        self,
        input_list : List[TNode],
        complete_path : bool = True,
        attempted_endpoint : Union[TNode,None] = None,
        is_directed = True
    ):
        self.path = input_list
        self._vertex_set = None
        self._adjacency_map = None
        self.is_empty = (len(input_list) > 0)
        self.start = input_list[0] if len(input_list) > 0 else None
        # Even if it's incomplete, a path has an endpoint.
        # This inherit empty endness from empty startness if the path is empty :)
        self.end = input_list[-1] if len(input_list) > 1 else self.start
        self.complete_path = complete_path
        if not complete_path:
            # If it is not a complete path, must convey the attempted endpoint to the caller.
            if attempted_endpoint is None:
                raise ValueError(f"Incomplete path not given a specified endpoint. Start point was {self.start}.")
        self.attempted_endpoint = attempted_endpoint if (not complete_path) else self.end

    def get_vertex_set(self) -> Set[TNode]:
        if self._vertex_set:
            return self._vertex_set

        self._vertex_set = set(self.path)
        return self._vertex_set

    def get_adjacency_map(self) -> Dict[TNode, Set[TNode]]:
        if self._adjacency_map:
            return self._adjacency_map
        retdict = {}
        if self.path == []:
            return retdictt
        if len(self.path) == 1:
            return {self.path[0] : set() }
        if len(self.path) == 2:
            return {self.path[0] : set([self.path[1]])}
        for i in range(0,len(self.path-2)):
            retdict.update({self.path[i]: set([self.path[i + 1]]) })
        retdict.update({self.path[-1] : set()})
        self._adjacency_map = retdict
        return retdict

    def __contains__(self, item) -> bool:
        return item in self.get_vertex_set()

    def __iter__(self):
        yield from self.path

    def __eq__(self, other):
        self.path == other.path

    def __len__(self):
        return len(self.path)

    def deep_copy(self):
        newcenter = deep_copy(center)
        newleaves = deep_copy(leaves)
        return Star(newcenter, newleaves, is_directed=self.is_directed)


###### Every graph here can get a path between vertices, if combinatorially possible.  ####

def get_path_between_star_vertices(star : Star[T,U], vertex_a : Union[T,U], vertex_b : Union[T,U]) -> Path[Union[T,U]]:
    if vertex_a == star.center:
        if vertex_b == star.center:
            return Path([star.center])
        else:
            if vertex_b not in star.leaves:
                raise ValueError(f"vertex_b {vertex_b} was not in the star!")
            return Path([center,vertex_b])
    else:
        if vertex_a not in star.leaves:
            raise ValueError(f"vertex_a {vertex_a} was not in the star!")
        if vertex_b not in star.leaves:
            if vertex_b == star.center:
                if star.is_directed:
                    # Directed from center -> leaves, can't get to center from leaf.
                    return Path(
                        [vertex_a],
                        complete_path=False,
                        attempted_endpoint=vertex.b
                    )
                else:
                    return Path([vertex_a, vertex_b])
            else:
                raise ValueError(f"vertex_b {vertex_b} was not in the star!")
        else:
            if star.is_directed:
                # Can't get to the center and bounce back to the other leaf.
                return Path(
                        [vertex_a],
                        complete_path=False,
                        attempted_endpoint=vertex.b
                )
            else:
                # path is complete
                return Path([vertex_a, star.center, vertex_b])




class Tree(Generic[TNode]):
    """A functional tree, somewhat hacked into Python's type system.

    :param TNode: The type of the Node of the tree.
    :param TTree: The type of the subtrees. Really it's Tree itself but
    python isn't quite smart enough for that.
    :param empty: Is the tree the empty tree? Defaults to False.
    :type empty: Boolean, optional
    :param root: The root of the tree is a Node with a list of TTrees.
    :type root: Union[None,List[TNode,TTree]]
    :raises ValueError: A value error is raised if:
        - the tree is said to be empty but passed a non-None root
        - the tree is not empty but the root is None

    """

    def __init__(
        self,
        empty=False,
        nonempty_tree: Union[Tuple[T, list], None] = None
    ):
        # Validate the constructor:
        # Initialize to an invalid but (semantically) empty tree.
        self.empty = False
        self.root = None
        self.branches = []
        self.is_leaf = False
        if empty:
            self.empty = True
            # Now the tree is valid. We need to make sure that the root
            # is either itself empty (which is sloppy but OK),
            # or None (better)
            if nonempty_tree is not None:
                raise ValueError("Tree was supplied True for empty in constructor, but was also supplied a nonempty tree")
        elif nonempty_tree is None:
            raise ValueError("Tree was said to be nonempty but was supplied empty root in its constructor")
        else:
            self.root = nonempty_tree[0]
            self.branches = nonempty_tree[1]
            self.is_leaf = bool(self.root and (not self.branches))

    def get_vertex_set(self) -> Set[TNode]:
        """Recursively builds the vertex set of the tree by:
            - adding the root to an existing (initially empty) vertex set
            - going through each of the branches, adding the root to the vertex set,
            - until each subtree is empty.

        :raises ValueError: Validates in the construction: if a cycle is detected,
        a ValueError is raised. A cycle is detected if the vertex set encounters a duplicate
        during its recursive construction.
        :return: A set of every vertex in the Tree.
        :rtype: Set[TNode]
        """
        retset = set()
        if self.empty:
            return retset
        retset.add(self.root)
        for subtree in self.branches:
            new_vertices = subtree.get_vertex_set()
            # We perform validation here: if we find an intersection between
            # the current set of vertices and the vertices in an unvisited
            # branch of the tree, that implies a cycle: throw an error.
            if retset.intersection(new_vertices):
                raise ValueError("Invalid tree configuration, somehow the vertices of the subtrees intersected with the vertices of the roots")
            retset.update(new_vertices)
        return retset

    def get_adjacency_map(self) -> Dict[TNode, List[TNode]]:
        """Returns a dictionary describing adjacency, as described at the top of this module.

        :return: A dictionary of vertex keys : list of vertices indicating which are adjacent to that key.
        :rtype: Dict[TNode, List[TNode]]
        """
        retdict = {}
        if self.empty:
            return retdict
        else:
            nonempty_branches = list(filter(lambda x: not x.empty, self.branches))
            vertices_adjacent_to_root = set(map(lambda x: x.root, nonempty_branches))
            retdict.update({self.root : vertices_adjacent_to_root})
            for branch in nonempty_branches:
                retdict.update(branch.get_adjacency_map())
            return retdict

    def __eq__(self, other) -> bool:
        if self.empty and other.empty:
            return True
        else:
            return (self.root == other.root and self.branches == other.brances)

    def __contains__(self, item) -> bool:
        if self.empty:
            return False
        elif self.root == item:
            return True
        else:
            return item in self.get_vertex_set()

    def __iter__(self):
        if self.empty:
            pass # Does this work? Behavior I want is to break from a `for x in emptytree` immediately.
        else:
            yield self.root
            for subtree in branches:
                yield from subtree


def __get_undirected_map_from_directed_map(adjacency_map: Dict[T, Set[T]]) -> Dict[T, Set[T]]:
    """Very dangerous (but thread-safe) helper function that symmetrizes an adjacency map.

    :param adjacency_map: [description]
    :type adjacency_map: Dict[T, Set[T]]
    :return: [description]
    :rtype: Dict[T, Set[T]]
    """
    adjacency_map_builder = deep_copy(adjacency_map)
    for key in adjacency_map:
        for node in adjacency_map[key]:
            adjacency_map_builder[node].add(key)
    return adjacency_map_builder


def __get_path_between_vertices(
    adjacency_map: Dict[T, List[T]],
    vertex_a : T,
    vertex_b : T,
    vertex_set : Union[Set[T],None] = None,
    blacklisted_vertices : Set[T] = set()
) -> Path[T]:
    """Private helper method for *attempting* to get the path between two vertices.
    WARNING: This will return an incomplete path if not possible.
    It is on the caller to make sure that returned_path[0], returned_path[-1] = vertex_a and vertex_b, respectively.

    This function is slow and naive. It will really only work reliably if the number of
    nodes in the graph is small.

    :param adjacency_map: The adjacency map of a graph.
    :type adjacency_map: Dict[T, List[T]]
    :param vertex_a: [description] The vertex the path should start at.
    :type vertex_a: T
    :param vertex_b: The vertex the path should end at.
    :type vertex_b: T
    :param vertex_set: Optional parameter, can cache the vertex_set or let the function do it.
    :param blacklisted_vertices: The vertices the path is not allowed to visit.
    Should be an empty set when this is first called, but perhaps there is
    a compelling reason to add to the blacklist initially.
    This is used in recursive calls to mark vertices that were already visited.
    :type blacklisted_vertices: Set[T]
    :raises ValueError: If either vertex_a or vertex_b aren't in the adjacency_map's keys.
    :return: An *ATTEMPTED*, possibly incomplete path between vertex_a and vertex_b, satisfying:
        - each element of the list is a vertex of the adjacency_map
        - for each i in 0..length_of_list-2, ls[i + 1] is in adjancency_map[ls[i]]
    :rtype: List[T]
    """
    if not vertex_set:
        vertex_set = set(adjacency_map.key())
    if vertex_a not in vertex_set:
        raise ValueError(f"Vertex {vertex_a} not in the adjacency map's vertex set!")
    if vertex_b not in vertex_set:
        raise ValueError(f"Vertex {vertex_b} not in the adjacency map's vertex set!")
    path_builder = [vertex_a]
    adjacent_vertices = adjacency_map[vertex_a]
    adjacency_set = set(adjacent_vertices)
    visited_vertices = blacklisted_vertices.add(vertex_a)
    complete_path_found = False
    if vertex_b in adjacency_set:
        # Then vertex_b is adjancent to vertex a and we are done:
        # the path has two elements, vertex_a and vertex_b.
        path_builder.append(vertex_b)
        return Path(path_builder)
    else:
        # if vertex_a and vertex_b are not adjacent,
        #   - iterate over the vertices that *are* adjacent to vertex_a
        #   - for each adjacent vertex, call __get_path_between_vertices with the same vertex_b endpoint.
        #
        next_part_of_path = []
        # slow and dumb
        for adj in adjacent_vertices:
            # Try to get the path recursively.
            next_part_of_path = __get_path_between_vertices(adjacency_map, adj,vertex_b, blacklisted_vertices=visited_vertices)
            # If the endpoint returned is NOT vertex_b,
            # then there was no path between adj and vertex_b.
            if next_part_of_path[-1] != vertex_b:
                continue
            else:
                path_builder = path_builder + next_part_of_path
                complete_path_found = True
                break
        # If at the end of the loop we still haven't found a match,
        # then there indeed is no path.
        # Return the partial path, it is on the caller to check it.
        if next_part_of_path[-1] != vertex_b:
            path_builder = path_builder + next_part_of_path
    return Path(path_builder, complete_path=complete_path_found, attempted_endpoint=vertex_b)


def __is_adjacency_map_connected(
    adjacency_map: Dict[T, List[T]],
    loops_allowed = False,
    is_directed = True,
    hypergraph_allowed = False,
    vertices : Union[Set[T],None] = None
) -> bool:
    """[summary]

    :param adjacency_map: [description]
    :type adjacency_map: Dict[T, List[T]]
    :param loops_allowed: [description], defaults to False
    :type loops_allowed: bool, optional
    :param is_directed: [description], defaults to True
    :type is_directed: bool, optional
    :param hypergraph_allowed: [description], defaults to False
    :type hypergraph_allowed: bool, optional
    :return: [description]
    :rtype: bool
    """
    if not vertices:
        vertices = set(adjacency_map.keys())
    if not vertices:
        # An empty graph is connected.
        return True
    for vertex in vertices:
        vertex_set_copy = vertices.copy()
        vertex_set_copy.remove(vertex)
        for vertex2 in vertex_set_copy:
            path = __get_path_between_vertices(adjacency_map, vertex, vertex2)
            if not path.complete_path:
                # then the graph is disconnected
                return False
    return True


def _validate_adjancency_map_of_graph(
    adjacency_map: Dict[T, List[T]],
    loops_allowed = False,
    is_directed = True,
    hypergraph_allowed = False,
    vertex_set : Union[Set[T], None] = None
) -> bool:
    """Private internal function to validate that Graphs are topologically/combinatorially valid.
    Called by Graph constructor.

    :param adjacency_map: Our model of graphs - a Dictionary where the keys are vertices (the vertices of the graph)
    and the values are lists of vertices (the vertices the key is adjacent to).
    :type adjacency_map: Dict[T, List[T]]
    :param loops_allowed: [description], defaults to False
    :type loops_allowed: bool, optional
    :param is_directed: [description], defaults to True
    :type is_directed: bool, optional
    :param hypergraph_allowed: [description], defaults to False
    :type hypergraph_allowed: bool, optional
    :raises ValueError: If the vertex_set is provided, we compare it to the keys of the adjancey_map.
    If they are not the same, a ValueError is raised.
    :raises ValueError: For each List[T] in the adjacency map's values,
    we assert that each element of that list must be in the vertex_set (and hence the adjacency map's keys)
    :raises ValueError: [description]
    :raises ValueError: [description]
    :return: [description]
    :rtype: bool
    """

    if not vertex_set:
        vertex_set = set(adjacency_map.keys())
    else:
        # The vertex set MUST equal the keys of the adjacency map if it is seaprately provided.
        # Note: this goes both ways: keys not in a provided vertex set are invalid, as is
        # vertex_est elements without a corresponding key in the adjacency map.
        # The adjacecny map MUST contain that vertex, even if it has no edges.
        if vertex_set != set(adjacency_map.keys()):
            raise ValueError(f"Inconsistent vertex_set (length {len(vertex_set)}) and adjacency_map, (length {len(set(adjacency_map.keys()))})")
    for vertex in vertex_set:
        adjacent_vertices = adjacency_map[vertex]
        for adj in adjacent_vertices:
            if adj not in vertex_set:
                raise ValueError(f"Vertex {adj} was not in the vertex set of the provided adjacency map. It must have at least an empty entry.")
            if not loops_allowed:
                if adj == vertex:
                    raise ValueError(f"Loops were not allowed but found in the provided adjacency map. Loop vertex: {adj}")
            if not is_directed:
                other_direction_adjacency = set(adjacency_map[adj])
                if vertex not in other_direction_adjacency:
                    raise ValueError(f"Adjacency map was said to be undirected but the edge ({vertex,adj}) did not have a matching reverse.")
        if not hypergraph_allowed:
            set_adjacency = set(adjacent_vertices)
            if len(set_adjacency) != len(adjacent_vertices):

                # Then we found a loop and we already know the graph is invalid.
                # For helpful logging purposes, we iterate over the vertices anyway
                # and identify the first concrete loop we come across.
                grouped = group_by(adjacent_vertices, lambda x: x)
                for v in grouped:
                    if len(grouped[v]) > 2:
                        # This should be guaranteed to hit.
                        # TODO: Test that it always hits on hypergraphs.
                        raise ValueError(f"Graph was not a hypergraph yet {vertex} had multiple (specifically {len(grouped[v])})edges to the same vertex, {v}.")
    # If we survived all these vertex-wide checks,
    # return True.
    return True



def safely_validate_adjacency_map(
    adjacency_map: Dict[T, List[T]],
    loops_allowed = False,
    is_directed = True,
    hypergraph_allowed = False,
    vertex_set : Union[Set[T], None] = None,
    logger_callback : Union[Callable[[Exception], None], None] = None,
) -> bool:
    """[summary]

    :param adjacency_map: [description]
    :type adjacency_map: Dict[T, List[T]]
    :param loops_allowed: [description], defaults to False
    :type loops_allowed: bool, optional
    :param is_directed: [description], defaults to True
    :type is_directed: bool, optional
    :param hypergraph_allowed: [description], defaults to False
    :type hypergraph_allowed: bool, optional
    :param vertex_set: [description], defaults to None
    :type vertex_set: Union[Set[T], None], optional
    :param logger_callback: [description], defaults to None
    :type logger_callback: Union[Callable[[Exception], None], None], optional
    :return: [description]
    :rtype: bool
    """
    try:
        return _validate_adjancency_map_of_graph(
            adjacency_map,
            loops_allowed=loops_allowed,
            is_directed=is_directed,
            hypergraph_allowed=hypergraph_allowed,
            vertex_set=vertex_set
        )
    except Exception as e:
        if logger_callback:
            logger_callback(e)
        return False


class Graph(Generic[T]):
    """A graph is a set of vertices with an adjacency relation between them.
    There is very little more structure than this, but we do parameterize some validations
    for specific types of graphs.

    We use a computationally-inefficient and unreliable, but intuitive, model of graph adjacency:
    adjacency is determined by a Dictionary[T, List[T]], where the keys are adjacent
    to each List[T] in the dictionary.

    For example:
        The complete graph on 3 vertices {a, b, c} can be defined by the following adjacency dictionary:
        {a : [b,c],
         b : [a,c],
         c : [a,b]}
        A binary tree can be described as follows:
            Vertex set: {1,2,3,4,5,6,7,8,9}
            Adjacency dictionary: {
                1 : [2,5]
                2 : [3,4]
                4 : [6,7]
                3 : [8,9]
            }


    :param T: The type of the graph's vertices. WARNING: This type *must* implement __hash__.
    :param adjacency: Adjacency is described by a Dictionary[node, list of nodes].
    :param loops_allowed: [description], defaults to False
    :type loops_allowed: bool, optional
    :param is_directed: [description], defaults to True
    :type is_directed: bool, optional
    :param hypergraph_allowed: [description], defaults to False
    :type hypergraph_allowed: bool, optional
    :raises ValueError: If the graph does not pass the checks in _validate_adjancency_map_of_graph.

    """

    def __init__(
        self,
        adjacency: Dict[T, Set[T]],
        loops_allowed = False,
        is_directed = True,
        hypergraph_allowed = False,
    ):
        vertex_set = set(adjacency.keys())
        if not _validate_adjancency_map_of_graph(
            adjacency,
            loops_allowed,
            is_directed,
            hypergraph_allowed,
            vertex_set,
        ):
            raise ValueError("Invalid graph")
        self.vertices = vertex_set
        self.adjacency = adjacency

    def __contains__(self, item):
        return item in self.vertices

    def __len__(self):
        return len(self.vertices)

    def __iter__(self):
        yield from self.vertices

    def get_neighbors(self, vertex: T) -> Set[T]:
        return self.adjacency[vertex]


def get_path_between_two_vertices(graph: Graph[T], vertex_a: T, vertex_b: T):
    try_path = __get_path_between_vertices(graph.adjacency, vertex_a, vertex_b)
    return try_path

def get_connected_components(graph: Graph[T]) -> List[Graph[T]]:
    for vertex in graph:
        visited_vertices = set()
        visited_vertices.add(vertex)
        for neighbor in graph.get_neighbors(vertex):
            if neighbor in visited_vertices:
                continue
            visited_vertices.add(neighbor)



